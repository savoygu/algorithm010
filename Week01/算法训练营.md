# 算法训练营

## 如何高效学习

### 三分看视频理解、七分练习

#### 视频：

##### 最佳办法：

###### 1.5~2.0倍速播放、难点（暂停+反复）

##### 最差办法：

###### 类似看美剧一样，原速看完，仅一遍

###  摒弃“旧”习惯 - 最重要

#### 学习方式

##### 不要死磕（传统方式）

##### 五毒神掌（敢于放手、敢于死记硬背代码）

##### 不懒于看高手代码（国际版的高票回答）

#### 解题方式

##### 最佳方式

###### 5分钟想不出来，直接看题解或高票代码，用五毒神掌变成自己的东西。
这个过程：觉得自己很菜甚至有点自卑，但是有借势而起的感觉

##### 最差方式

###### 看到题目想自己单挑一下，不借助外部帮助自己解决；以为15-30分钟可以搞定，谁知道死磕了2-3小时或一晚上，终于“通过”。
精疲力尽，没精力学习高票程序答案，就开始做下一题（或放弃）。

### 学习方法上

#### 改变自己的学习习惯（不要死磕）

#### 五毒神掌（重要的是 五！过遍数，而不是每次花很长时间）

#### 不要死磕AC了事，要看高票代码和高质量题解！

#### 最大误区：LeetCode 题目只做一遍！（90%素人、30%学员）

#### 应该如何？做 5 遍 ！做 5 遍！做 5 遍！

## 解题思路

### 没有思路的时候

看能不能暴力解
想最简单的情况下应该怎么做，
想出来之后，就要看怎么泛化，泛化的思路就是找重复性，
这里是最近重复子问题，
为什么要找重复性呢？因为我们的计算机它只能做这种 if  else for loop 和 recursion ，
正是这样一个原因，层层嵌套在一起，最后发现你的思路，最后是把所有题目都只能
往这个方向去做和思考，这么一想，你就会发现万事万物它的规律就这么一点，很简单的。
所有解决问题，它的思路就是变成一个找重复性，因为我们的程序只能做重复的事情。

#### 暴力

#### 基本情况

##### 以爬楼梯为例

###### 想：第一阶 怎么办，第二阶 怎么办

#### 找 最近 重复子问题（泛化）

为什么找重复子问题呢？因为我们写程序只能写 if else 、for while 这样的 loop 、recursion
然后是程序不断调自己和递归。除了 if else 这种简单的问题之外，
其他的情况下 for while 和 recursion 的话都是不断的重复，究其原因，计算机是人类发明的，
人类发明出来的工具，肯定没有人脑强啊，它其实就是一个简单的重复式的机器，
就是再加上我们现在用的这些程序和这些算法，都是最简单的算法，所以不涉及任何人工智能的东西，
你就把它想成一个不断重复在那里干事情的东西就好了，你要让它用重复的东西来解决你这种问题的话说明什么，
说明这个问题本身就是可重复的，把这个想完之后，后面讲什么回溯、分治、动态规划、递归，全部都是找重复性

##### 如何找重复性？

以爬楼梯为例：你要上到第三级台阶，你要怎么上？
因为每次只能走一步和每次只能走两步，
所以你只能从第二级台阶跨一步到第三级台阶来，
第二种走法是从第一级台阶一下跨两步到第三级台阶，
没有其他的走法了，所以你只能从 n - 1级台阶走过来 或者 n - 2 级台阶走过来，
那么从爬楼梯可以看出，
第三级台阶就等于第一级台阶的走法加上第二级台阶的走法即可

递推公式：

f(3) = f(1) + f(2)
f(4) = f(2) + f(3)
f(n) = f(n - 1) + f(n - 2)

#### 所有的问题， 到最后， 都是找重复性

## 预习

### 数据结构与算法总览

#### 如何系统学习数据结构与算法

##### 线上课程

###### 预习 — 基础知识自己预习和查看

###### 课堂互动 — 跟着老师一起思考、回答问题

###### 课后作业 — 按照切题办法

##### 期待效果

###### 职业顶尖级别 — 对于算法数据结构的理解

###### 一线互联网面试

###### LeetCode 300+ 的积累

##### 精通一个领域

###### Chunk it up 切碎知识点

####### 把要学习的知识点切碎变成一个有机的整体

####### 关键点

######## 庖丁解牛

######## 脉络相连

######### 任何知识体系都是一棵树，所谓他叫做语法树，
那你关键要掌握这个领域的知识的话，就是要把知识变成树状结构，
有最基本的根，分出主干，再分出枝叶，每个知识点的话，
要最后和你熟悉的知识挂靠在一起，成为一个树形结构。
就是人脑不适合记忆和理解孤立的知识，所以一定要把它弄成一个脑图

###### Deliberate Practicing 刻意练习

####### 职业化运动

######## 基本功是区别业余和职业选手的根本

######## 基础动作的分解训练和反复练习

####### 刻意练习

######## 刻意练习 — 过遍数 （五毒神掌）

######## 练习缺陷、弱点地方

######## 可能会有这样的感觉：不舒服、不爽、枯燥

###### Feedback 反馈

####### 主动式反馈（自己去找）

######## 高手代码

######### Github、LeetCode

####### 被动式反馈（高手给你指点）

######## Code Review

##### 数据结构和算法知识脉络

###### 数据结构

####### 一维数据结构

######## 基础

######### 数组 array

######### 链表 linked list

######## 高级

######### 栈 stack

########## 特点

########### 后进先出

######### 队列 queue

########## 特点

########### 先进先出

######### 双端队列 deque

######### 集合 set

######### 映射 map (hash or map )

####### 二维数据结构

######## 基础

######### 树 tree

######### 图 graph

######## 高级

######### 二叉搜索树 binary search tree

########## 特点

########### 它的根节点的话大于它的左子树且小于它的右子树的全部节点，
同时以此类推下去，也就是相对有序的一颗二叉树，就叫做儿叉搜索树

########## 特殊结构

########### 红黑树 red-black tree

########### AVL

######### 堆 heap

######### 并查集 disjoint set 

######### 字典树 Trie

####### 特殊数据结构

######## 位运算 Bitwise

######## 布隆过滤器 BloomFilter

######## LRU Cache（高频）

###### 算法

####### if-else, switch ——> branch

####### for, while loop ——> Iteration

####### 递归 Recursion (Divide & Conquer, BackTrace)

####### 搜索 Search

######## 深度优先搜索 Depth first Search ( DFS )

######## 广度优先搜索 Breadth first Search ( BFS )

######## 启发式搜索 A*

####### 动态规划 Dynamic Programming

####### 二分查找 Binary Search

####### 贪心 Greedy

####### 数学 Math，几何 Geometry

##### 刷题技巧

###### 切题四件套：
刷单个题目之前，养成四步系统化的思考方式

####### Clarification

######## 和面试官及自己多看几次题目，
和面试官反复沟通一下题目，确保自己对
这个题目的理解是正确的

####### Possible solutions：
想可能的解法来解这个题目，
关键是把所有可能的解法，先过一遍，
同时比较不同解法它们的时间和空间复杂度，
从中找出最优的一种解法

######## compare (time/space)

######## optimal (加强)

####### Coding （多写）

####### Test cases

######## 多列举几个测试样例

###### 五遍刷题法（五毒神掌）

####### 刷题第一遍

######## 5-15分钟：读题+思考

######### 把题目理解了，然后思考可能的解法

######## 没思路的话，直接看解法：注意！多解法，比较不同解法优劣

######## 背诵、默写好的解法（同时理解）

####### 刷题第二遍

######## 马上自己写 —> LeetCode 提交

######### 有 bug 也没关系，不断 debug、修改，直到提交通过

######## 多种解法比较、体会 —> 优化！

######### 每种解法都写一遍

######### 每一种解法的话在 leetcode 上面的它还会有不同的执行时间和内存消耗，
最重要的是执行时间，不同解法比较执行时间，同时对于同一解法的话，执行时间要是偏长的话，
想一下优化的办法。直到这些不同的解法通过，而且的话执行时间相对是较优的。

####### 刷题第三遍

######## 过了24小时后，再重复做一遍之前做过的题目

######## 不同解法的熟练程度 —> 专项练习

######### 不同解法的熟练程度要是不一样的话，
对自己不是特别熟练的题目做专项练习

####### 刷题第四遍

######## 过了一周：反复回来练习相同题目

######## 对于不熟练的题目 —> 专项练习 

####### 刷题第五遍

######## 面试前一周恢复性训练

### 训练准备和复杂度分析

#### 训练准备

##### 电脑设置

###### 搜索引擎设置为 Google

###### Mac： iTerm2 + zsh 

##### 指法和小操作

###### home，end

###### Word 单词、选单词、选整行

###### IDE的自动补全

###### Top tips for <IDE-name>

##### 自顶向下的编程方式

#### 时间和空间复杂度

##### 时间复杂度：

###### Big O notation
注意：只看最高复杂度的运算

####### O(1):   Constant Complexity 常数复杂度

####### O(log n) Logarithmic Complexity 对数复杂度

####### O(n): Linear Complexity 线性时间复杂度

####### O(n^2): N square Complexity 平方

####### O(n^3): N cubic Complexity 立方

####### O(2^n): Exponential Growth 指数

####### O(n!): Factorial 阶乘

###### 时间复杂度曲线

#######  

###### 更复杂的情况：递归

####### 主定理

######## 常用算法复杂度计算

######### 二分查找 Binary Search

########## Recurrence relationship

########### T(n) = T(n/2) + O(1)

########## Run time

########### O(log n)

######### 二叉树遍历 Binary tree traversal

########## Recurrence relationship

########### T(n) = 2T(n/2) + O(1)

########## Run time

########### O(n)

######### 排好序的二维矩阵 Optimal sorted matrix search

########## Recurrence relationship

########### T(n) =2 T(n/2) + O(log n)

########## Run time

########### O(n)

######### 归并排序 Merge sort

########## Recurrence relationship

########### T(n) =2 T(n/2) + O(log n)

########## Run time

########### O(n log n)

###### 思考题

####### 二叉树遍历 - 前序、中序、后续：时间复杂度是多少？

######## 分析

######### 不管是前序中序后序它遍历二叉树的时候，
每个节点会访问一次且仅访问一次，
所以它的时间复杂度就是线性于二叉树的节点总数，
也就是 O(n) 的时间复杂度

######## 答案

######### O(n)

####### 图的遍历：时间复杂度是多少？

######## 分析

######### 图里面的每个节点访问一次且仅访问一次，所以它的时间复杂度为 O(n)，
这里的 n 的话是图的里面的节点总数

######## 答案

######### O(n)

####### 搜索算法：DFS、BFS 时间复杂度是多少？

######## 分析

######### 因为访问的节点只访问一次，
所以它的时间复杂度都是 O(n) 的，
这里的 n 指的是搜索空间里的节点总数

######## 答案

######### O(n)

####### 二分查找：时间复杂度是多少？

######## 分析

######## 答案

######### O(log n)

##### 空间复杂度

###### 实战情况

####### 数组的长度

######## 如果你的代码中开辟了数组，那么数组的长度，基本上就是你的空间复杂度。
比如说：你开了一个一维的数组，它的长度为传入的数组的个数，那么一般来说你的空间复杂度就是 O(n)
如果你开的是两维数组，数组的长度是 n 平方，那么你的空间复杂度基本上就是 n 平方的；

####### 递归的深度（特殊说明）

######## 如果有递归的话，那么递归最深的深度，就是你的空间复杂度的最大值；
当然了，如果又是递归里面又开了数组，那就是两者之间的最大值就是你的时间复杂度

## 第一周

### 数组、链表、跳表

#### 数组 Array

##### 复杂度分析

###### 时间复杂度

####### 首位添加 (prepend)：O(1)

######## 注意：正常情况下数组的 prepend 操作的事件复杂度是 O(n)，
但是可以进行特殊优化到 O(1)。采用的方式是申请稍大一些的内存空间，
然后在数组最开始预留一部分空间，然后prepend 的操作就是把头下标前移一个位置即可。

####### 末位追加 (append)：O(1)

####### 查找 (lookup)：O(1)

####### 插入 (insert)：O(n)

####### 删除 (delete): O(n)

#### 链表 Linked List

##### 分类

###### 单链表 Single Linked List

###### 双链表 Double Linked List

##### 复杂度分析

###### 时间复杂度

####### 首位添加 (prepend)：O(1)

####### 末位追加 (append)：O(1)

####### 查找 (lookup)：O(n)

####### 插入 (insert)：O(1)

####### 删除 (delete)：O(1)

###### 空间复杂度

##### 工程应用

###### 最少最近使用算法 LRU ( Least Recently Use ) 

##### 练习建议

###### 解法非常的固定，主要就是熟能生巧，没有很多算法的东西，
关键就是要熟悉怎么把 next 指针、prev 指针 换过来换过去，
要熟悉的办法就是多做，同时还是五遍刷题法一定要做，
同时所有 Linked List 这题目的话，大家在写以前的话一定要再都写一遍这些高频的 LInked List

#### 跳表 Skip List

##### 特点

###### 注意：只能用于元素有序的情况。

###### 所以，跳表（skip list）对标的是平衡树（AVL Tree）和二分查找，
是一种 插入/删除/搜索 都是 O(log n) 的数据结构。1989 年出现。

###### 它最大的优势是原理简单、容易实现、方便扩展、效率更高。因此
在一些热门的项目里用来替代平衡树，如 Redis、LevelDB 等。

##### 复杂度分析

###### 时间复杂度

####### 查找 loopup：O(logn)

###### 空间复杂度

####### O(n)

原始链表大小为 n，每 2 个结点抽 1 个，每层索引的结点数：
n/2 , n/4 , n/8 , ⋯ , 8,4,2
原始链表大小为 n，每 3 个结点抽 1 个，每层索引的结点数：
n/3 , n/9 , n/27 , ⋯ , 9,3,1

空间复杂度是 O(n)

##### 工程运用

###### 数据库 Redis

#### 题目分析

##### 移动零

##### 盛水最多的容器、爬楼梯

##### 3数之和、环形链表

### 栈、队列、优先队列、双端队列

#### 栈 Stack

##### 特点

###### 先入后出 FILO（ First in Last out ）

##### 复杂度

###### 时间复杂度

####### 添加 O(1)

####### 删除 O(1)

####### 查询 O(n)

###### 空间复杂度

##### 题目解析

###### Leetcode 20 题 有效括号

##### 应用场景

###### 最近相关性

#### 队列 Queue

##### 特点

###### 先入先出 FIFO（ First in - First out ）

##### 复杂度

###### 时间复杂度

####### 添加 O(1)

####### 删除 O(1)

####### 查询 O(n)

##### 应用场景

###### 先来后到

#### 优先队列 （Priority Queue）

##### 复杂度

###### 时间复杂度

####### 添加 O(1)

####### 删除 O(1)

####### 查询 O(log n)

######## 为什么是 O(log n) 呢？
里面的数据结构保持了一定的有序性，是一些高级的数据结构。
具体里面用了什么数据结构呢？
底层具体实现的数据结构较为多样和复杂：可以是 heap （也是多种实现的）、bst、treap

#### 双端队列 Deque （Double-End Queue）

##### 特点

###### 两端可以进出的

##### 复杂度

###### 时间复杂度

####### 添加 O(1)

####### 删除 O(1)

####### 查询 O(n)

### 核心思想

#### 升维

#### 空间换时间

## 第二周

### 哈希表、映射、集合

### 树、二叉树、二叉搜索树

### 堆和二叉堆、图

## 第三周

### 泛型递归、树的递归

### 分治、回溯

## 第四周

### 深度优先搜索（DFS）和广度优先搜索（BFS）

### 贪心算法

### 二分查找

## 第五周

### 期中考试

## 第六周

### 动态规划

## 第七周

### 字典树和并查集

### 高级搜索

### 红黑树和 AVL 树

## 第八周

### 位运算

### 布隆过滤器和LRU缓存

### 排序算法

## 第九周

### 高级动态规划

### 字符串算法

## 第十周

### 毕业考试
